module timingctrl (
        input       clk
        ,input      rst_n
        ,input      send_done
        ,input      reply
        ,output     reg ENABLE
);
localparam ST0 = 3'b001;
localparam ST1 = 3'b010;
localparam ST2 = 3'b100;
reg [2:0]STATE;
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        ENABLE <= 1'b0;
    end
    else begin
        if (STATE == ST0) begin
            ENABLE <= 1'b1;
        end
        else begin
            ENABLE <= 1'b0;
        end
    end
end
always @(posedge clk or negedge rst_n) begin
    if (rst_n) begin
        STATE <= ST0;
    end
    else begin
        case (STATE)
        ST0    :begin
            if (send_done) begin
                STATE <= ST1;
            end
        end 
        ST1    :begin
            if (reply) begin
                STATE <= ST2;
            end
            if (overtime) begin
                STATE <= ST0;
            end
        end
        ST2     :begin
            if (waittime) begin
                STATE <= ST0;
            end
        end
            default: STATE <= ST0;
        endcase
    end
end
reg overtime_en;
always @(*) begin
    if (rst_n) begin
        overtime_en <= 1'b0;
    end
    else begin
        if (STATE == ST1) begin
            overtime_en <= 1'b1;
        end
        else begin
            overtime_en <= 1'b0;
        end
    end
end
reg waittime_en;
always @(*) begin
    if (rst_n) begin
        waittime_en <= 1'b0;
    end
    else begin
        if (STATE == ST2) begin
            waittime_en <= 1'b1;
        end
        else begin
            waittime_en <= 1'b0;
        end
    end
end
counter #(
    .RST(120000),//1ms
    .START(0)
)
c1(
    .clk(clk)
    ,.rst_n(rst_n)
    ,.asyn(send_done)
    ,.en(overtime_en)
    ,.pulse(overtime)
);
counter #(
    .RST(2500), //  200us
    .START(0)   
)
c2(
    .clk(clk)
    ,.rst_n(rst_n)
    ,.asyn(reply)
    ,.en(waittime_en)
    ,.pulse(waittime)
);
endmodule